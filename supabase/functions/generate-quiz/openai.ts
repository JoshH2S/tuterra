import { corsHeaders } from './constants.ts';

interface Topic {
  name: string;
  questionCount: number;
}

interface Question {
  question: string;
  options: {
    A: string;
    B: string;
    C: string;
    D: string;
  };
  correct_answer: string;
  topic: string;
}

interface TeacherContext {
  teacherName?: string;
  school?: string;
}

const MAX_TOKENS = 4000;
const TOKENS_PER_CHAR = 4;
const MAX_RETRIES = 3;
const INITIAL_RETRY_DELAY = 1000; // 1 second

function estimateTokens(text: string): number {
  return Math.ceil(text.length / TOKENS_PER_CHAR);
}

function chunkContent(content: string, maxTokens: number): string[] {
  const chunks: string[] = [];
  let currentChunk = '';
  const paragraphs = content.split('\n\n');

  for (const paragraph of paragraphs) {
    const paragraphTokens = estimateTokens(currentChunk + paragraph);
    
    if (paragraphTokens > maxTokens && currentChunk) {
      chunks.push(currentChunk.trim());
      currentChunk = paragraph;
    } else {
      currentChunk += (currentChunk ? '\n\n' : '') + paragraph;
    }
  }

  if (currentChunk) {
    chunks.push(currentChunk.trim());
  }

  return chunks;
}

function distributeQuestionCounts(topics: Topic[], chunkCount: number): Topic[][] {
  const totalQuestions = topics.reduce((sum, t) => sum + t.questionCount, 0);
  const questionsPerChunk = Math.ceil(totalQuestions / chunkCount);
  
  return Array(chunkCount).fill(null).map(() => 
    topics.map(topic => ({
      ...topic,
      questionCount: Math.ceil(topic.questionCount / chunkCount)
    }))
  );
}

async function makeOpenAIRequest(prompt: string, retryCount = 0): Promise<Question[]> {
  try {
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${Deno.env.get('OPENAI_API_KEY')}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'gpt-4o-mini',
        messages: [
          {
            role: 'system',
            content: 'You are an expert at creating multiple choice quiz questions. Return a valid JSON array of questions.'
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        response_format: { type: "json_object" }
      }),
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({ error: response.statusText }));
      
      // Handle rate limiting
      if (response.status === 429 && retryCount < MAX_RETRIES) {
        const retryDelay = INITIAL_RETRY_DELAY * Math.pow(2, retryCount);
        console.log(`Rate limited. Retrying in ${retryDelay}ms (attempt ${retryCount + 1}/${MAX_RETRIES})`);
        await new Promise(resolve => setTimeout(resolve, retryDelay));
        return makeOpenAIRequest(prompt, retryCount + 1);
      }

      throw new Error(`OpenAI API error: ${errorData.error || response.statusText}`);
    }

    const data = await response.json();
    console.log('OpenAI API response received successfully');

    if (!data.choices?.[0]?.message?.content) {
      throw new Error('Invalid response format from OpenAI');
    }

    const parsed = JSON.parse(data.choices[0].message.content);
    const questions = Array.isArray(parsed) ? parsed : parsed.questions;
    
    if (!Array.isArray(questions)) {
      throw new Error('Response does not contain a valid questions array');
    }

    // Validate question structure
    questions.forEach((q, idx) => {
      if (!q.question || !q.options || !q.correct_answer || !q.topic) {
        throw new Error(`Question ${idx + 1} is missing required fields`);
      }
      if (!['A', 'B', 'C', 'D'].includes(q.correct_answer)) {
        throw new Error(`Question ${idx + 1} has invalid correct_answer: ${q.correct_answer}`);
      }
    });

    return questions;
  } catch (error) {
    if (retryCount < MAX_RETRIES && error.message.includes('Too Many Requests')) {
      const retryDelay = INITIAL_RETRY_DELAY * Math.pow(2, retryCount);
      console.log(`Rate limited. Retrying in ${retryDelay}ms (attempt ${retryCount + 1}/${MAX_RETRIES})`);
      await new Promise(resolve => setTimeout(resolve, retryDelay));
      return makeOpenAIRequest(prompt, retryCount + 1);
    }
    throw error;
  }
}

export async function generateQuestionsWithOpenAI(
  content: string,
  topics: Topic[],
  openAIApiKey: string,
  teacherContext: TeacherContext = {}
): Promise<Question[]> {
  console.log('Starting question generation, content length:', content.length);
  
  const chunks = chunkContent(content, MAX_TOKENS);
  console.log(`Content split into ${chunks.length} chunks`);
  
  const topicDistribution = distributeQuestionCounts(topics, chunks.length);
  const allQuestions: Question[] = [];

  const teacherInfo = teacherContext.teacherName ? 
    `Generated by ${teacherContext.teacherName}${teacherContext.school ? ` from ${teacherContext.school}` : ''}` :
    'Generated quiz';

  for (let i = 0; i < chunks.length; i++) {
    const chunk = chunks[i];
    const chunkTopics = topicDistribution[i];
    
    console.log(`Processing chunk ${i + 1}/${chunks.length}, length: ${chunk.length}`);
    console.log('Topics for this chunk:', chunkTopics);

    const prompt = `${teacherInfo}

Generate multiple choice quiz questions from this content:
${chunk}

Generate questions for these topics:
${chunkTopics.map((topic, index) => `${index + 1}. ${topic.name} (${topic.questionCount} questions)`).join('\n')}

Each question MUST have exactly four options (A, B, C, D) and one correct answer.
Format your response as a JSON array of questions, where each question has this structure:
{
  "question": "the question text",
  "options": {
    "A": "first option",
    "B": "second option",
    "C": "third option",
    "D": "fourth option"
  },
  "correct_answer": "A/B/C/D",
  "topic": "topic name"
}`;

    try {
      const chunkQuestions = await makeOpenAIRequest(prompt);
      allQuestions.push(...chunkQuestions);
      console.log(`Added ${chunkQuestions.length} questions from chunk ${i + 1}`);
    } catch (error) {
      console.error(`Error processing chunk ${i + 1}:`, error);
      throw error;
    }
  }

  // Ensure we have the correct number of questions per topic
  const questionsByTopic = new Map<string, Question[]>();
  for (const question of allQuestions) {
    if (!questionsByTopic.has(question.topic)) {
      questionsByTopic.set(question.topic, []);
    }
    questionsByTopic.get(question.topic)!.push(question);
  }

  const finalQuestions: Question[] = [];
  for (const topic of topics) {
    const topicQuestions = questionsByTopic.get(topic.name) || [];
    finalQuestions.push(...topicQuestions.slice(0, topic.questionCount));
  }

  console.log('Final question count:', finalQuestions.length);
  return finalQuestions;
}
